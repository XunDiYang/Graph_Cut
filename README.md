# Graph_Cut
2019-2020上 BIT 数据图像处理大作业-图割

## 环境

- 编程软件：visual studio code
- 语言：python 3.7
- numpy 1.17.4
- opencv-python 4.1.2.30
- tqdm 4.40.2
- pymaxflow 1.2.12

## 代码文件说明

- code

  - graph_cut.py

    实现图割

  - maxflow_dinic.py

    手动实现最大流算法，由于效果不怎么样，所以没用

## 方法原理

​		Graph-Cut 是由Yuri Y.Boykov 等人于2001 年提出的交互式的图像分割算法。

​		该方法的主要思想是和图的最大流最小割问题相关联，首先构造一个无向图G=<V, E>表示要分割的图，该无向图的点由图片全部的像素点和两个端点 s，t 构成，边由两种边构成，一种是 n-links 即每两个邻域顶点（对应于图像中每两个邻域像素）的连接，另一种是 t-links 即每个普通顶点和这 2 个终端顶点之间的连接。在前后景分割中，s 一般表示前景目标，t 一般表示背景。

​		其中每一条边都有一个非负的权值 w，也可以称之为 cost。一个割就是边集合 E 的一个子集 C，该割的 cost 就是子集 C 所有边的权值之和。

​		Graph Cut 算法的目的就是求一个最小割，这个最小割把图的顶点划分为两个不相交的子集 S 和 T，其中其中 s ∈S，t∈ T 和 S∪T=V。这两个子集就对应于图像的前景像素集和背景像素集，那就相当于完成了图像分割。

​		图割可以看作为像素标记问题，这个过程可以通过最小化图割来最小化能量函数得到。假设整幅图的像素集为 A = (𝐴1, … 𝐴𝑝)，其中Ai是”obj”或者”bkg”，向量 A 定义了一次分割，设定每次分割的损失函数如下

​										E(A) = λR(A) + B(A)

​		其中，
$$
R(A)=∑_{p\in P} R_p (A_p)
$$
​	
$$
B(A) = \sum_{\{p,q\}\in N}B_{\{p,q\}} \cdot \delta(A_p,A_q)
$$
​		且
$$
\delta(A_p,A_q) = \left\{
\begin{array}{rcl}
1    &  & {if A_p \neq A_q}\\
0    &  & {otherwise}
\end{array} \right.
$$
​		其中，R(A)为区域项，B(A)为边界项，λ是区域项和边界项之间的重要因子，决定它们对能量的影响大小。

​		在区域项计算公式中，𝑅𝑝(𝐴𝑝)表示为像素 p 分配标签𝐴𝑝的惩罚，𝑅𝑝(𝐴𝑝)能量项的权值可以通过比较像素 p 的灰度和给定的目标和前景的灰度直方图或者通过RGB 三通道的混合高斯模型 GMM 来获得 (本次作业采用的是单通道高斯模型获得的)。为了使相似度高的损失小，一般对概率取负对数，公式如下:
$$
R_p("obj") = -lnPr(I_p | O)
$$

$$
R_p("bkg") = -lnPr(I_p | B)
$$

​		在边界项计算公式中，p 和 q 为邻域像素，边界项主要体现分割 A 的边界属性，𝐵{p,q}可以解析为像素 p 和 q 之间不连续的惩罚，如果 p 和 q 越相似，那么𝐵{p,q}越大，如果他们非常不同，那么𝐵{p,q}就接近于 0, 𝐵{p,q}的计算公式如下：
$$
B_{\{p,q\}} \propto exp(-\frac{(I_p-I_q)^2}{2\delta^2})\cdot \frac{1}{dist(p,q)}
$$
​		使用上述公式建立好图之后，便能通过最大流最小割的各种算法找到最小割了，而最小割就是对应着损失函数最小。割完之后所有和 s 处于同一子集的像素点便是前景。